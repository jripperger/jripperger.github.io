<h1>Blog Post 1 on the Pragmatic Programmer</h1>
<h3>This post references Chapter 1: <i>A Pragmatic Philosophy</i></h3>

<p>In this chapter, the topic that was most interesting to me was "Good-Enough Software". This section of
    the chapter discussed the importance of not spending an excessive amount of time attempting to perfect software.
    When coding for my previous computer science classes, I always attempted to make my code entirely unbreakable--essentially
    using destructive testing on my algorithms. At times, this method of testing resulted in me spending hours fixing on 
    a problem that did not affect the primary functioning of the code. Moreover, the problems were so trivial that if I 
    had not toyed with the program, the professor would not have even noticed the issue when grading the assignment.
</p>
<p>After reading this section, I will be more aware of the costs and benefits of fixing problems within my code--not only on
    my current CS assignments, but also any work that I do in the future. Throughout my career as a programmer, it is likely 
    that some of the programs that I will create are going to have a certain "tolerance" to them; in other words, some error 
    will be allowed. I will produce the best work that I can within a reasonable time frame, but I will also analyze the benefits
    of spending extensive periods of time attempting to fix various issues. I now further recognize the advantages of allowing 
    users to play with the programs. User feedback is simply a much easier means of determining the successes and failures of 
    my code, and it enables me, as the programmer, to seek out the true areas where improvement is needed within my code.
</p>